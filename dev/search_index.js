var documenterSearchIndex = {"docs":
[{"location":"VARmodel/","page":"VAR model","title":"VAR model","text":"CurrentModule = Destabilisation","category":"page"},{"location":"VARmodel/#VAR-models","page":"VAR model","title":"VAR models","text":"","category":"section"},{"location":"VARmodel/","page":"VAR model","title":"VAR model","text":"The VAR model we use in this case is of the following form: x_t = ν + A_1 (x_traj_t-1 p_traj_t-1 h(x_traj_t-1 p_traj_t-1))     +  + A_p (x_traj_t-p p_traj_t-p h(x_traj_t-p p_traj_t-p))","category":"page"},{"location":"VARmodel/","page":"VAR model","title":"VAR model","text":"where x_traj_t is the trajectory of the observables at time t, p_traj_t is the trajectory of the parameters at time t and h is a function that allows for non-linearities in the model.","category":"page"},{"location":"VARmodel/","page":"VAR model","title":"VAR model","text":"All relevant information about the VAR model is stored in the struct:","category":"page"},{"location":"VARmodel/","page":"VAR model","title":"VAR model","text":"VARmodel","category":"page"},{"location":"VARmodel/#Destabilisation.VARmodel_module.VARmodel","page":"VAR model","title":"Destabilisation.VARmodel_module.VARmodel","text":"VARmodel\n\nAn element of the struct VARmodel contains all the information needed to define a VAR model.\n\nFields\n\nh::Union{Function,Nothing}: function that computes the regressor of the form (x_t',p_t',h(x_t,p_t)')'\np::Int64: order of the VAR model\nd_x::Int64: dimension of the observable variable\nd_p::Int64: dimension of the parameter variable\nd_h::Int64: dimension of the hidden variable\nd_y::Int64: dimension of the augmented variable\nB_hat::Matrix{Float64}: estimated coefficient matrix\nΣ_hat_u::Matrix{Float64}: estimated covariance matrix of the residuals (unbiased estimator)\nΣ_tilde_u::Matrix{Float64}: estimated covariance matrix of the residuals (maximum likelihood)\nΣ_β_hat::Matrix{Float64}: estimated covariance matrix of the coefficient matrix (unbiased estimator)\nΓ_hat::Matrix{Float64}: estimator for YY'/T\nΣ_x1_hat::Matrix{Float64}: estimated MSE matrix of the one step forecast (unbiased estimator)\n\n\n\n\n\n","category":"type"},{"location":"VARmodel/","page":"VAR model","title":"VAR model","text":"The following function can be used to predict the next observable values given a VAR model and the current values of the observables and parameters:","category":"page"},{"location":"VARmodel/","page":"VAR model","title":"VAR model","text":"oneStepPred","category":"page"},{"location":"VARmodel/#Destabilisation.VARmodel_module.oneStepPred","page":"VAR model","title":"Destabilisation.VARmodel_module.oneStepPred","text":"oneStepPred(model::VARmodel,x_traj::Matrix;p_traj::Union{Matrix,Nothing}=nothing)\n\nCompute the one step prediction of the VAR model given by model for the trajectory x_traj and the parameter trajectory p_traj. If p_traj is not given, it is assumed that the VAR model is time invariant.\n\n\n\n\n\n","category":"function"},{"location":"testParameterDependences/","page":"Test parameter dependence","title":"Test parameter dependence","text":"CurrentModule = Destabilisation","category":"page"},{"location":"testParameterDependences/#Test-Parameter-Dependence","page":"Test parameter dependence","title":"Test Parameter Dependence","text":"","category":"section"},{"location":"testParameterDependences/","page":"Test parameter dependence","title":"Test parameter dependence","text":"The following function can be used to find the locations of the parameter dependent coefficients in the regressor of a given VAR model","category":"page"},{"location":"testParameterDependences/","page":"Test parameter dependence","title":"Test parameter dependence","text":"getParamLocations","category":"page"},{"location":"testParameterDependences/#Destabilisation.getParamLocations","page":"Test parameter dependence","title":"Destabilisation.getParamLocations","text":"get_param_locations(model::VARmodel, param_idx::Int64)\n\nReturns the indices of the observables that depend on the parameter with index param_idx in the form of an array     which can be used as the argument param_locations in the function C.\n\n\n\n\n\n","category":"function"},{"location":"testParameterDependences/","page":"Test parameter dependence","title":"Test parameter dependence","text":"In order to determine if the observables significantly depend on the parameters, the following function can be used","category":"page"},{"location":"testParameterDependences/","page":"Test parameter dependence","title":"Test parameter dependence","text":"testParamCausality","category":"page"},{"location":"testParameterDependences/#Destabilisation.testParamCausality","page":"Test parameter dependence","title":"Destabilisation.testParamCausality","text":"testParamCausality(model::VARmodel, param_idx::Int64, T::Int64; siglvl::Float64 = 0.01)\n\nReturns a tuple (is_causal, p_value) where is_causal is a boolean indicating whether or not the parameter with      index param_idx is causal for the observables in the VAR model model and p_value is the p-value of the      test. In order to compute the test statistic it is necessary to give the length T of the timeseries, that was     used to estimate the VAR model. The test is performed at significance level siglvl.\n\n\n\n\n\n","category":"function"},{"location":"home/","page":"Home","title":"Home","text":"CurrentModule = Destabilisation","category":"page"},{"location":"home/#FiveBoxModel","page":"Home","title":"FiveBoxModel","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Documentation for Destabilisation.","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"This model can be use to destabilize stochastic dynamical systems.","category":"page"},{"location":"testVARmodel/","page":"Test VAR model","title":"Test VAR model","text":"CurrentModule = Destabilisation","category":"page"},{"location":"testVARmodel/#Test-estimated-VAR-models","page":"Test VAR model","title":"Test estimated VAR models","text":"","category":"section"},{"location":"testVARmodel/","page":"Test VAR model","title":"Test VAR model","text":"Here we pesent some tests that we can perform on estimated VAR models in order to check their validity.","category":"page"},{"location":"testVARmodel/","page":"Test VAR model","title":"Test VAR model","text":"In this first test we present a function that quantifies the validity of a model by comparing the one step predictions of the model with the actual values of the observables by performing a hypothesis test.","category":"page"},{"location":"testVARmodel/","page":"Test VAR model","title":"Test VAR model","text":"testPredictions","category":"page"},{"location":"testVARmodel/#Destabilisation.testPredictions","page":"Test VAR model","title":"Destabilisation.testPredictions","text":"testPredictions(model::VARmodel,\n    x_traj::Matrix;\n    p_traj::Union{Matrix,Nothing}=nothing,\n    siglvl::Float64=0.05)\n\nThis function tests the validity of the given VAR model by checking the prediction error of the model.      The prediction error is computed as the sum of the squared nomalized, uncorrlated prediction errors      of the model.      The prediction error is then compared to the critical value of the χ² distribution with degrees      of freedom equal to the number of observations times the number of variables.     If the percentil of the prediction error is smaller than the significance level siglvl, the model     is rejected.     The function returns a tuple consisting of a boolean value whether the model is accepted or not     and the percentil of the prediction error. \n\n\n\n\n\n","category":"function"},{"location":"testVARmodel/","page":"Test VAR model","title":"Test VAR model","text":"The whiteness i.e. the absence of autocorrelation in the residuals of the model is tested by the following function.","category":"page"},{"location":"testVARmodel/","page":"Test VAR model","title":"Test VAR model","text":"LMtest","category":"page"},{"location":"testVARmodel/#Destabilisation.LMtest","page":"Test VAR model","title":"Destabilisation.LMtest","text":"LMtest(model::VARmodel,h::Int64,x_traj::Matrix;p_traj::Union{Matrix,Nothing}=nothing,siglvl::Float64=0.05)\n\nThis function is the implementation of the Lagrange multiplier test for testing the whiteness of the residuals.     Here x_traj and p_traj are the trajectories used to estimate the model. h determines up to how many lags     we test for uncorrelated residualts. siglvl is the significance level of the test.\n\n\n\n\n\n","category":"function"},{"location":"timeScales/","page":"Time scales","title":"Time scales","text":"CurrentModule = Destabilisation","category":"page"},{"location":"timeScales/#Determine-time-scales-of-VAR-models","page":"Time scales","title":"Determine time scales of VAR models","text":"","category":"section"},{"location":"timeScales/","page":"Time scales","title":"Time scales","text":"The following method is used to determine the time scales of a VAR model. The time scales are determined by the eigenvalues of the VAR model.","category":"page"},{"location":"timeScales/","page":"Time scales","title":"Time scales","text":"timeScale","category":"page"},{"location":"timeScales/#Destabilisation.timeScale","page":"Time scales","title":"Destabilisation.timeScale","text":"timeScale(model::VARmodel)\n\nDetermines a proxy of the slowest timescale of the VAR model model by returning the absolute value of the smallest     root of the characteristic polynomial of the VAR model. This is done by fitting a polynomial of degree deg to     the function f(z) = det(Id - sum([z^i * B_i for i in 1:p])) where B_i is the i-th block of the matrix B_hat     of the VAR model model. The root of this polynomial with the smallest absolute value (which should be larger than     one for the model to be stable) is returned.     Note that this function can only be applied to VAR models without parameter variables and without hidden variables.\n\n\n\n\n\ntimeScale(B_hat::Matrix{Float64})\n\nAuxiliary function that returns the timescale for a given matix B_hat\n\n\n\n\n\ntimeScale(progressor::Function, \n            v_init::Vector{Float64}, \n            p_init::Vector{Float64}; \n            T_init::Int64 = 200,\n            T_max::Int64 = 10000,\n            rel_error::Float64 = 1e-1)\n\nDetermines a proxy of the slowest timescale of the dynamical system defined by the progressor function     progressor with given initial state variables v_init and parameter variables p_init.      This is done by integrating the dynamical system for a time T_init and then doubling the time until     the error on the time scale approximation is smaller than rel_error * abs(ts - 1). The function then      returns the time scale approximation and the error on the approximation.\n\n\n\n\n\ntimeScale(progressor::Function, \n            v_init::Vector{Float64}, \n            p_init::Vector{Float64}; \n            T_init::Int64 = 200,\n            T_max::Int64 = 10000,\n            rel_error::Float64 = 1e-1)\n\nDetermines a proxy of the slowest timescale of the observable dynamics of the the dynamical systen DS.      This is done by integrating the dynamical system for a time T_init and then doubling the time until     the error on the time scale approximation is smaller than rel_error * abs(ts - 1). The function then      returns the time scale approximation and the error on the approximation.\n\n\n\n\n\n","category":"function"},{"location":"timeScales/","page":"Time scales","title":"Time scales","text":"This function uses the following auxiliary function which turns a given function into a polynomial","category":"page"},{"location":"timeScales/","page":"Time scales","title":"Time scales","text":"toPolynomial","category":"page"},{"location":"timeScales/#Destabilisation.toPolynomial","page":"Time scales","title":"Destabilisation.toPolynomial","text":"toPolynomial(f::Function; deg::Int64 = 1, tolerance::Float64 = 1e-4)\n\nFit a polynomial of degree deg to the function f. The polynomial is fitted using the least squares method. The     accuracy of the polynomial is checked by comparing the function f to the polynomial on 100 equidistant points     in an appropriately chosen interval. If the maximum error is larger than tolerance, a warning is issued.     Finally the polynomial is returned.\n\n\n\n\n\n","category":"function"},{"location":"parameterSeries/","page":"Parameter series","title":"Parameter series","text":"CurrentModule = Destabilisation","category":"page"},{"location":"parameterSeries/#Parameter-Series","page":"Parameter series","title":"Parameter Series","text":"","category":"section"},{"location":"parameterSeries/","page":"Parameter series","title":"Parameter series","text":"This method is used to generate a series parameter values.","category":"page"},{"location":"parameterSeries/","page":"Parameter series","title":"Parameter series","text":"parameterSeriesGenerator","category":"page"},{"location":"parameterSeries/#Destabilisation.parameterSeriesGenerator","page":"Parameter series","title":"Destabilisation.parameterSeriesGenerator","text":"parameterSeriesGenerator(ts::Float64, p_init::Vector{Float64}, noise::Vector{Float64}; n::Union{Int64,Nothing} = nothing)\n\nGenerate a parameter series given the time scale of the system, the initial parameter values as well as the noise amplitudes.     The series has the form of a VAR(1) process with the given time scale and the given noise amplitudes varying around the     given initial parameter values. The length of the parameter series is determined by the time scale if not specified.\n\nArguments\n\nts::Float64: The time scale of the system which for instance can be determined using the timeScale function.\np_init::Vector{Float64}: The initial parameter values.\nnoise::Vector{Float64}: The noise amplitudes.\nn::Union{Int64,Nothing} = nothing: The length of the parameter series. If not specified the length is determined by the time scale.\nkeep_const::Int64 = 1: If this argument is larger than 1, the length of the parameter series is increased by a    factor of keep_const as each parameter value is kept constant for keep_const time steps. So the resulting   parameter series are of the form [p1,...,p1,p2,...,p2,...,pn,...,pn]\n\n\n\n\n\n","category":"function"},{"location":"integrate/","page":"Integrate trajectories","title":"Integrate trajectories","text":"CurrentModule = Destabilisation","category":"page"},{"location":"integrate/#Integrate-trajectories","page":"Integrate trajectories","title":"Integrate trajectories","text":"","category":"section"},{"location":"integrate/","page":"Integrate trajectories","title":"Integrate trajectories","text":"integrateTraj","category":"page"},{"location":"integrate/#Destabilisation.integrateTraj","page":"Integrate trajectories","title":"Destabilisation.integrateTraj","text":"integrateTraj(DS::DynamicalSystem, g::Function, T::Int64; include_reference_traj::Bool=false)\n\nThis function iteratively computes the evolution of the state variables v, the parameters p and the     observables.\n\nArguments\n\nDS::DynamicalSystem: Element of the type DynamicalSystem which encodes the dynamics of the system under   considerantion\ng::Function: Function determining the one-step evolution of the parameter values. I.e. g must be such that   it takes one Argument p::Vector{Float64} containing the current parameter values and returns the new    parameter values again in the form of Vector{Float64}\nT::Int64: Number of time steps\ninclude_reference_traj::Bool=false: If true, the reference trajectory is included in the output\n\nReturns\n\n`varr': Vector of dimension (DS.lengthv,T) containing the time evolution of the state space variable\n`parr': Vector of dimension (DS.lengthp,T) containing the time evolution of the parameters\n`xarr': Vector of dimension (DS.lengthx,T) containing the time evolution of the observables\nv_ref_arr': This is only returned ifincludereferencetraj==true.   Vector of dimension (DS.length_v,T) containing the v values which are obtained by computing   the next timestep using the past v value as given invarrbut the initial parameter valuesDS.pinit.   IfDS.randomveclength !== nothing` then the same noise is used for both integrations.\nx_ref_arr': This is only returned ifincludereferencetraj==trueand is obtained by applying theobservablefunction of theDynamicalSystemobject tovrefarrandDS.p_init`.\nnoise': This is only returned ifDS.randomveclength !== nothing`.   Vector of dimension (DS.randomveclength,T) containing the noise values which are used for the integration   of the reference trajectory.\n\n\n\n\n\nintegrateTraj(DS::DynamicalSystem, p_traj::Matrix{Float64}; include_reference_traj::Bool=false)\n\nThis function iteratively computes the evolution of the state variables v and the observables x of a system forced by     a given trajectory of the parameters p. The trajectories for v, p and x are always returned as the first there     return values. If include_reference_traj is set to true, the function also returns additional trajectories of     v and x for fixed parameters which in each timestep are computed from the v values of the trajectories with      varying parameters, allowing for a comparison of the trajectories with varying and fixed parameters. If the      field random_vec_length of the DynamicalSystem is not nothing, then the same noise is used for both the     trajectory with variing parameters and the one with fixed parameters and the function additionaly returns the      noise trajectory. This is also the case if the field random_vec_length is not nothing while      include_reference_traj is set to false.\n\n\n\n\n\nintegrateTraj(DS::DynamicalSystem, T::Int64)\n\nIntegrates the trajectory of a system for T time steps with constant parameters and returns the trajectory of     the state variables v, the parameters p and the observables. If the field random_vec_length of the      DynamicalSystem is not nothing, the function also returns the noise vector containing the noise trajectory     used to integrate the system.\n\n\n\n\n\n","category":"function"},{"location":"coupling/","page":"Coupling to dynamical system","title":"Coupling to dynamical system","text":"CurrentModule = Destabilisation","category":"page"},{"location":"coupling/#Coupling-the-destabilataions-package-to-the-dynamical-system","page":"Coupling to dynamical system","title":"Coupling the destabilataions package to the dynamical system","text":"","category":"section"},{"location":"coupling/","page":"Coupling to dynamical system","title":"Coupling to dynamical system","text":"The struct DynamicalSystem allows acces to the parameter dependent dynamics of the underlying system and also gives information about how to comupte the observables of interest.","category":"page"},{"location":"coupling/","page":"Coupling to dynamical system","title":"Coupling to dynamical system","text":"DynamicalSystem\nDynamicalSystem(progressor,observable,x_init,p_init;p_bounds=nothing)","category":"page"},{"location":"coupling/#Destabilisation.DynamicalSystem","page":"Coupling to dynamical system","title":"Destabilisation.DynamicalSystem","text":"DynamicalSystem\n\nAn instance of the struct DynamicalSystem contains all the relevant information of the stochastic dynamical      system which we want to destabilize.\n\nFields\n\nprogressor::Function: In the case of a deterministic dynamical system of a stochastic dynamical system where   we have no controll over the stochasticity,   the Argument progressor should contains a function that takes two arguments, each of type   Vector{Float64}, representing the current state variables v and the current parameter values p and returns   the state variables for the next timestep as a Vector{Float64}. I.e. this function describes the progression   of the dynamical system for one time step. In the case of a stochastic dynamical system, i.e. if   random_vec_length !== nothing the function takes an additional argument random_vec::Vector{Float64} which    is a random vector of the type Vector{Float64} of length random_vec_length. So it makes sense to plug   a vector of the form randn(random_vec_length) into the third argument of the function progressor.\nobservable::Function: This function should take the current state variables v and the current parameter values p,   both as Vector{Float64}, as input and return an output of type Vector{Float64} containing all the observables   of the system which are relevant for further analysis.\nv_init::Vector{Float64}: Initial values for the state space variables.\np_init::Vector{Float64}: Initial parameter values.\np_bounds::Union{Vector{Tuple},Nothing}: In case the parameter values are bounded to certain intervalls, the   bounds of each of these intervalls can be specified in this argument. I.e. the i-th tuple in p_bounds    represent the interval bounds for the i-th parameter. If p_bounds = nothing then it is assumes that there   are no restictions to the parameter values\nv_length::Int64: Number of state space variables\np_length::Int64: Number of parameters\nx_length::Int64: Number of observables\nrandom_vec_length::Union{Int64,Nothing}: If the dynamical system is stochastic, i.e. if random_vec_length !== nothing   then this argument specifies the length of the random vector which is used in the function progressor to   describe the stochasticity of the system. If random_vec_length = nothing then it is assumed that the system   is deterministic, or that we have no controll over the stochasticity of the system.\n\n\n\n\n\n","category":"type"},{"location":"matrices/","page":"Matrices","title":"Matrices","text":"CurrentModule = Destabilisation","category":"page"},{"location":"matrices/#Matrices","page":"Matrices","title":"Matrices","text":"","category":"section"},{"location":"matrices/","page":"Matrices","title":"Matrices","text":"Here some usefull functions are presented which return matrices which are for instance needed to fit a model to the recored data.","category":"page"},{"location":"matrices/","page":"Matrices","title":"Matrices","text":"slice_traj\nX\nY_t\nY\nId\nJ\ncreate_y_traj\nF_i\nF\nC","category":"page"},{"location":"matrices/#Destabilisation.slice_traj","page":"Matrices","title":"Destabilisation.slice_traj","text":"slice_traj(data::Matrix; p::Int64=1, T::Int64=100)\n\nSlices out the last T+p columns from the data argument. Here p denotes the number of presamples and T encodes the number of actual samples. \n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.X","page":"Matrices","title":"Destabilisation.X","text":"X(traj::Matrix; p::Int64=1, T::Union{Int64,Nothing}=nothing)\n\nThis function turns a trajectory traj, which is a matrix with K rows, into a matrix X as defined     in Lütkepohls book in equation (3.2.1) (where it is called Y) by slicing the last T colomns from the traj argument.      If T===nothing then T is set to the number of     columns of traj minus p i.e. the traj argument is interpreted in such a way that it     consists of all the presamples plus all the actual samples. If on the other hand T is given     and T+p is not equal to the length of the trajectory, i.e. traj has less than T+p columns,     an error is throuwn.     As always p denotes the number of presamples and T encodes the number of actual samples. \n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.Y_t","page":"Matrices","title":"Destabilisation.Y_t","text":"Y_t(traj::Matrix, t; p::Int64=1)\n\nReturns the vector Yₜ as defined e.g. in equation (3.2.1) in Lütkepohls book (where it is called Zₜ). Here it is assumed     that the trajectory traj includes the presample datapoints i.e. yₜ from the book corresponds     to the column of traj with index t+p.     As always p denotes the number of presamples.\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.Y","page":"Matrices","title":"Destabilisation.Y","text":"Y(traj; p::Int64=1, T::Union{Int64,Nothing}=nothing)\n\nReturns Y as defined in Lütkepohls book in equation (3.2.1) (where it is called Z). If the number of columns of     the trajectory traj does not equal T+p then an error is throuwn.      As always p denotes the number of presamples and T encodes the number of actual samples. \n\n\n\n\n\nY(x_traj::Matrix{Float64}, p_traj::Matrix{Float64}, p_init::Vector{Float64} , h::Function, p::Int64 = 1)\n\nReturns the matrix Y that is needed when performing a VAR regression where a reference trajectory is included.     Here Y is a matrix of size (dp+dh*p) x (T-p) where T = size(x_traj, 2), dp = size(p_traj, 1) and     dh = size(h(x_traj[:,1], p_init), 1). The function returns a matrix where the t-th column is given by     Yₜ = [pₜ₊ₚ₋₁ - p_init; h(xₜ₊ₚ₋₁, pₜ₊ₚ₋₁ - p_init); ...; h(xₜ, pₜ - p_init)] where pₜ is the t-th column of      p_traj and xₜ is the t-th column of x_traj. \n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.Id","page":"Matrices","title":"Destabilisation.Id","text":"Id(d)\n\nReturns a d by d sparse identity matrix\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.J","page":"Matrices","title":"Destabilisation.J","text":"J(K::Int64, p::Int64)\n\nReturns the matrix J as defined in equation (2.1.11)\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.create_y_traj","page":"Matrices","title":"Destabilisation.create_y_traj","text":"create_y_traj(x_traj::Matrix{Float64};p_traj::Union{Matrix{Float64},Nothing}=nothing,h::Union{Function,Nothing}=nothing)\n\nThis function creates a trajectory y_traj from x_traj, p_traj and h s.t. the i-th column of y_traj is given by     (x_traj[:,i]', p_traj[:,i]', h(x_traj[:,i],p_traj[:,i])')'.\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.F_i","page":"Matrices","title":"Destabilisation.F_i","text":"F_i(i::Int64, T::Int64)\n\nReturns the matrix Fᵢ as defined in equation (4.4.2)\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.F","page":"Matrices","title":"Destabilisation.F","text":"F(h::Int64, T::Int64)\n\nReturns the matrix Fᵢ as defined in equation (4.4.2)\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.C","page":"Matrices","title":"Destabilisation.C","text":"C(param_locations::Vector{Int64}, d_x::Int64, d_y::Int64, p::Int64)\n\nC is the matrix as defined in section 3.6.1 in Lütkepohls book. It can be used to test if the observables in the      fitted VAR model show a dependence on a given parameter p. To this end the positions of the p dependent entries     of y = (x',p',h(x,p)')' must be known and encoded in the param_locations argument. The argument d_x denotes     the dimension of the x vector, d_y the dimension of the y vector and p the number of presamples. The function     then returns the respective matrix C of dimentions length(param_locations) × d_x * (p * d_y + 1) as a sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"formatTests/","page":"Format Test","title":"Format Test","text":"CurrentModule = Destabilisation","category":"page"},{"location":"formatTests/#Format-Test","page":"Format Test","title":"Format Test","text":"","category":"section"},{"location":"formatTests/","page":"Format Test","title":"Format Test","text":"These functions can be used to verify if a given object has indeed the desired format needed for the respecive application.","category":"page"},{"location":"formatTests/","page":"Format Test","title":"Format Test","text":"check_traj\ncheck_DynamicalSystem\ncheck_h\ncheck_xph","category":"page"},{"location":"formatTests/#Destabilisation.FormatTests.check_traj","page":"Format Test","title":"Destabilisation.FormatTests.check_traj","text":"check_traj(traj)\n\nChecks if traj has the format of a trajectory i.e. if traj is a two dimentional matrix with all entries     given by numbers. Further it is always assumed that each column of trajectory represents a datapoint     of the time series, i.e. each row denotes the time evolution of a single variable.\n\n\n\n\n\n","category":"function"},{"location":"formatTests/#Destabilisation.FormatTests.check_DynamicalSystem","page":"Format Test","title":"Destabilisation.FormatTests.check_DynamicalSystem","text":"check_DynamicalSystem(progressor,observable,v_init,p_init,p_bounds,v_length,p_length,x_length)\n\nCompatibility test for initialisation of an object of DynamicalSystem.\n\n\n\n\n\ncheck_DynamicalSystem(progressor,observable,v_init,p_init,p_bounds)\n\nCompatibility test for initialisation of an object of DynamicalSystem.\n\n\n\n\n\n","category":"function"},{"location":"formatTests/#Destabilisation.FormatTests.check_h","page":"Format Test","title":"Destabilisation.FormatTests.check_h","text":"check_h(h::Function, x_traj::Union{Matrix{Float64},Nothing}, p_traj::Union{Matrix{Float64},Nothing})\n\nCompatibility test for the function h used for the inclusion of non-linearities in the model. h is supposed     to be given by a Vector{Float64} valued function which takes one or two vector arguments, depending on whether     a timeseries of parameters is included or not.\n\n\n\n\n\n","category":"function"},{"location":"formatTests/#Destabilisation.FormatTests.check_xph","page":"Format Test","title":"Destabilisation.FormatTests.check_xph","text":"check_xph(x_traj::Matrix,p_traj::Union{Matrix,Nothing}=nothing,h::Union{Function,Nothing}=nothing)\n\nCompatibility test for simultaneously checking the trajectory x_traj, the parameter trajectory p_traj and      the function h. x_traj, p_traj and h are supposed to satify their individual compatibility tests      and in addition, the number of datapoints in x_traj and p_traj must be the same.      Besides checking the compatibility of x_traj, p_traj and h, the function also returns the dimensions     of the trajectory x_traj, the parameter trajectory p_traj and the output of h at the first datapoint      as d_x, d_p and d_h, respectively.\n\n\n\n\n\n","category":"function"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"CurrentModule = Destabilisation","category":"page"},{"location":"fitVARmodel/#Fitting-a-VAR-model-to-observed-data","page":"Fit VAR model","title":"Fitting a VAR model to observed data","text":"","category":"section"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"The VAR model we use in this case is of the following form: x_t = ν + A_1 (x_traj_t-1 p_traj_t-1 h(x_traj_t-1 p_traj_t-1))     +  + A_p (x_traj_t-p p_traj_t-p h(x_traj_t-p p_traj_t-p))","category":"page"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"where x_traj_t is the trajectory of the observables at time t, p_traj_t is the trajectory of the parameters at time t and h is a function that allows for non-linearities in the model.","category":"page"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"A suitable order p for the VAR model can be determined using the function:","category":"page"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"VARorder","category":"page"},{"location":"fitVARmodel/#Destabilisation.VARorder","page":"Fit VAR model","title":"Destabilisation.VARorder","text":"VARorder(traj::Matrix; p_max::Int64=10, criterion::String=\"AIC\")\n\nThis function computes the optimal order of a VAR model for a given trajectory x_traj by     minimizing the AIC, FPE, HQ or SC criterion. The optimal order is returned as an integer.     The p_max argument denotes the maximal order which is considered. If the system is forced     by varying parameter values the respective time series should be given in the p_traj argument     which must have the same number of datapoints as the x_traj argument. The h argument allows     for non-linearities to be included in the model. To this end h must be a vector valued function     which takes two arguments x and p if p_traj !== nothing and one argument x if p_traj === nothing.     So in total the optimal VAR order of a model of      the form x_traj_t = ν + A_1 (x_traj_{t-1}', p_traj_{t-1}', h(x_traj_{t-1}, p_traj_{t-1})')'     + ... + A_p (x_traj_{t-p}', p_traj_{t-p}', h(x_traj_{t-p}, p_traj_{t-p})')' is computed.\n\n\n\n\n\n","category":"function"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"After selecting a suitable order the VAR model can be fitted to the data using the function:","category":"page"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"fitVARmodel","category":"page"},{"location":"fitVARmodel/#Destabilisation.fitVARmodel","page":"Fit VAR model","title":"Destabilisation.fitVARmodel","text":"fitVARmodel(x_traj::Matrix; p_traj::Union{Matrix,Nothing}=nothing, h::Union(Function,Nothing)=nothing, p::Int64=1)\n\nFits a VAR(p) model of the form x_traj_t = ν + A_1 (x_traj_{t-1}', p_traj_{t-1}', h(x_traj_{t-1}, p_traj_{t-1})')'     + ... + A_p (x_traj_{t-p}', p_traj_{t-p}', h(x_traj_{t-p}, p_traj_{t-p})')' to the given input data. It returns     a VARmodel object which contains the estimated parameters and the estimated covariance matrices.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = Destabilisation","category":"page"},{"location":"#Destabilisation","page":"Index","title":"Destabilisation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Documentation for Destabilisation.","category":"page"},{"location":"","page":"Index","title":"Index","text":"","category":"page"}]
}
