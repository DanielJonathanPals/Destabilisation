var documenterSearchIndex = {"docs":
[{"location":"matrices/","page":"Matrices","title":"Matrices","text":"CurrentModule = Destabilisation","category":"page"},{"location":"matrices/#Matrices","page":"Matrices","title":"Matrices","text":"","category":"section"},{"location":"matrices/","page":"Matrices","title":"Matrices","text":"Here some usefull functions are presented which return matrices which are for instance needed to fit a model to the recored data.","category":"page"},{"location":"matrices/","page":"Matrices","title":"Matrices","text":"slice_traj\nX\nY_t\nY\nId\nJ\ncreate_y_traj","category":"page"},{"location":"matrices/#Destabilisation.slice_traj","page":"Matrices","title":"Destabilisation.slice_traj","text":"slice_traj(data::Matrix; p::Int64=1, T::Int64=100)\n\nSlices out the last T+p columns from the data argument. Here p denotes the number of presamples and T encodes the number of actual samples. \n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.X","page":"Matrices","title":"Destabilisation.X","text":"X(traj::Matrix; p::Int64=1, T::Union{Int64,Nothing}=nothing)\n\nThis function turns a trajectory traj, which is a matrix with K rows, into a matrix X as defined     in Lütkepohls book in equation (3.2.1) (where it is called Y) by slicing the last T colomns from the traj argument.      If T===nothing then T is set to the number of     columns of traj minus p i.e. the traj argument is interpreted in such a way that it     consists of all the presamples plus all the actual samples. If on the other hand T is given     and T+p is not equal to the length of the trajectory, i.e. traj has less than T+p columns,     an error is throuwn.     As always p denotes the number of presamples and T encodes the number of actual samples. \n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.Y_t","page":"Matrices","title":"Destabilisation.Y_t","text":"Y_t(traj::Matrix, t; p::Int64=1)\n\nReturns the vector Yₜ as defined e.g. in equation (3.2.1) in Lütkepohls book (where it is called Zₜ). Here it is assumed     that the trajectory traj includes the presample datapoints i.e. yₜ from the book corresponds     to the column of traj with index t+p.     As always p denotes the number of presamples.\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.Y","page":"Matrices","title":"Destabilisation.Y","text":"Y(traj; p::Int64=1, T::Union{Int64,Nothing}=nothing)\n\nReturns Y as defined in Lütkepohls book in equation (3.2.1) (where it is called Z). If the number of columns of     the trajectory traj does not equal T+p then an error is throuwn.      As always p denotes the number of presamples and T encodes the number of actual samples. \n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.Id","page":"Matrices","title":"Destabilisation.Id","text":"Id(d)\n\nReturns a d by d sparse identity matrix\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.J","page":"Matrices","title":"Destabilisation.J","text":"J(K::Int64, p::Int64)\n\nReturns the matrix J as defined in equation (2.1.11)\n\n\n\n\n\n","category":"function"},{"location":"matrices/#Destabilisation.create_y_traj","page":"Matrices","title":"Destabilisation.create_y_traj","text":"create_y_traj(x_traj::Matrix{Float64};p_traj::Union{Matrix{Float64},Nothing}=nothing,h::Union{Function,Nothing}=nothing)\n\nThis function creates a trajectory y_traj from x_traj, p_traj and h s.t. the i-th column of y_traj is given by     (x_traj[:,i]', p_traj[:,i]', h(x_traj[:,i],p_traj[:,i])')'.\n\n\n\n\n\n","category":"function"},{"location":"home/","page":"Home","title":"Home","text":"CurrentModule = Destabilisation","category":"page"},{"location":"home/#FiveBoxModel","page":"Home","title":"FiveBoxModel","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Documentation for Destabilisation.","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"This model can be use to destabilize stochastic dynamical systems.","category":"page"},{"location":"integrate/","page":"Integrate trajectories","title":"Integrate trajectories","text":"CurrentModule = Destabilisation","category":"page"},{"location":"integrate/#Integrate-trajectories","page":"Integrate trajectories","title":"Integrate trajectories","text":"","category":"section"},{"location":"integrate/","page":"Integrate trajectories","title":"Integrate trajectories","text":"integrateTraj","category":"page"},{"location":"integrate/#Destabilisation.integrateTraj","page":"Integrate trajectories","title":"Destabilisation.integrateTraj","text":"integrateTraj(DS::DynamicalSystem, g::Function, T::Int64, v_0::Vector{Float64}, p_0::Vector{Float64})\n\nThis function iteratively computes the evolution of the state variables v, the parameters p and the     observables.\n\nArguments\n\nDS::DynamicalSystem: Element of the type DynamicalSystem which encodes the dynamics of the system under   considerantion\ng::Function: Function determining the one-step evolution of the parameter values. I.e. g must be such that   it takes one Argument p::Vector{Float64} containing the current parameter values and returns the new    parameter values again in the form of Vector{Float64}\nT::Int64: Number of time steps\nv_0::Vector{Float64}: Initial values of the state variables\np_0::Vector{Float64}: initial parameter values\n\nReturns\n\n`varr': Vector of dimension (DS.lengthv,T) containing the time evolution of the state space variable\n`parr': Vector of dimension (DS.lengthp,T) containing the time evolution of the parameters\n`xarr': Vector of dimension (DS.lengthx,T) containing the time evolution of the observables\n\n\n\n\n\n","category":"function"},{"location":"formatTests/","page":"Format Test","title":"Format Test","text":"CurrentModule = Destabilisation","category":"page"},{"location":"formatTests/#Format-Test","page":"Format Test","title":"Format Test","text":"","category":"section"},{"location":"formatTests/","page":"Format Test","title":"Format Test","text":"These functions can be used to verify if a given object has indeed the desired format needed for the respecive application.","category":"page"},{"location":"formatTests/","page":"Format Test","title":"Format Test","text":"check_traj\ncheck_DynamicalSystem\ncheck_h\ncheck_xph","category":"page"},{"location":"formatTests/#Destabilisation.FormatTests.check_traj","page":"Format Test","title":"Destabilisation.FormatTests.check_traj","text":"check_traj(traj)\n\nChecks if traj has the format of a trajectory i.e. if traj is a two dimentional matrix with all entries     given by numbers. Further it is always assumed that each column of trajectory represents a datapoint     of the time series, i.e. each row denotes the time evolution of a single variable.\n\n\n\n\n\n","category":"function"},{"location":"formatTests/#Destabilisation.FormatTests.check_DynamicalSystem","page":"Format Test","title":"Destabilisation.FormatTests.check_DynamicalSystem","text":"check_DynamicalSystem(progressor,observable,v_init,p_init,p_bounds,v_length,p_length,x_length)\n\nCompatibility test for initialisation of an object of DynamicalSystem.\n\n\n\n\n\ncheck_DynamicalSystem(progressor,observable,v_init,p_init,p_bounds)\n\nCompatibility test for initialisation of an object of DynamicalSystem.\n\n\n\n\n\n","category":"function"},{"location":"formatTests/#Destabilisation.FormatTests.check_h","page":"Format Test","title":"Destabilisation.FormatTests.check_h","text":"check_h(h::Function, x_traj::Union{Matrix{Float64},Nothing}, p_traj::Union{Matrix{Float64},Nothing})\n\nCompatibility test for the function h used for the inclusion of non-linearities in the model. h is supposed     to be given by a Vector{Float64} valued function which takes one or two vector arguments, depending on whether     a timeseries of parameters is included or not.\n\n\n\n\n\n","category":"function"},{"location":"formatTests/#Destabilisation.FormatTests.check_xph","page":"Format Test","title":"Destabilisation.FormatTests.check_xph","text":"check_xph(x_traj::Matrix,p_traj::Union{Matrix,Nothing}=nothing,h::Union{Function,Nothing}=nothing)\n\nCompatibility test for simultaneously checking the trajectory x_traj, the parameter trajectory p_traj and      the function h. x_traj, p_traj and h are supposed to satify their individual compatibility tests      and in addition, the number of datapoints in x_traj and p_traj must be the same.      Besides checking the compatibility of x_traj, p_traj and h, the function also returns the dimensions     of the trajectory x_traj, the parameter trajectory p_traj and the output of h at the first datapoint      as d_x, d_p and d_h, respectively.\n\n\n\n\n\n","category":"function"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"CurrentModule = Destabilisation","category":"page"},{"location":"fitVARmodel/#Fitting-a-VAR-model-to-observed-data","page":"Fit VAR model","title":"Fitting a VAR model to observed data","text":"","category":"section"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"The VAR model we use in this case is of the following form: x_t = ν + A_1 (x_traj_t-1 p_traj_t-1 h(x_traj_t-1 p_traj_t-1))     +  + A_p (x_traj_t-p p_traj_t-p h(x_traj_t-p p_traj_t-p))","category":"page"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"where x_traj_t is the trajectory of the observables at time t, p_traj_t is the trajectory of the parameters at time t and h is a function that allows for non-linearities in the model.","category":"page"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"A suitable order p for the VAR model can be determined using the function:","category":"page"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"VARorder","category":"page"},{"location":"fitVARmodel/#Destabilisation.VARorder","page":"Fit VAR model","title":"Destabilisation.VARorder","text":"VARorder(traj::Matrix; p_max::Int64=10, criterion::String=\"AIC\")\n\nThis function computes the optimal order of a VAR model for a given trajectory x_traj by     minimizing the AIC, FPE, HQ or SC criterion. The optimal order is returned as an integer.     The p_max argument denotes the maximal order which is considered. If the system is forced     by varying parameter values the respective time series should be given in the p_traj argument     which must have the same number of datapoints as the x_traj argument. The h argument allows     for non-linearities to be included in the model. To this end h must be a vector valued function     which takes two arguments x and p if p_traj !== nothing and one argument x if p_traj === nothing.     So in total the optimal VAR order of a model of      the form x_traj_t = ν + A_1 (x_traj_{t-1}', p_traj_{t-1}', h(x_traj_{t-1}, p_traj_{t-1})')'     + ... + A_p (x_traj_{t-p}', p_traj_{t-p}', h(x_traj_{t-p}, p_traj_{t-p})')' is computed.\n\n\n\n\n\n","category":"function"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"After selecting a suitable order the VAR model can be fitted to the data using the function:","category":"page"},{"location":"fitVARmodel/","page":"Fit VAR model","title":"Fit VAR model","text":"VARmodel(x_traj::Matrix;\n    p_traj::Union{Matrix,Nothing}=nothing,\n    h::Union{Function,Nothing}=nothing,\n    p::Int64=1)","category":"page"},{"location":"fitVARmodel/#Destabilisation.VARmodel-Tuple{Matrix}","page":"Fit VAR model","title":"Destabilisation.VARmodel","text":"VARmodel(x_traj::Matrix; p_traj::Union{Matrix,Nothing}=nothing, h::Union(Function,Nothing)=nothing, p::Int64=1)\n\nFits a VAR(p) model of the form x_traj_t = ν + A_1 (x_traj_{t-1}', p_traj_{t-1}', h(x_traj_{t-1}, p_traj_{t-1})')'     + ... + A_p (x_traj_{t-p}', p_traj_{t-p}', h(x_traj_{t-p}, p_traj_{t-p})')' to the given input data. It returns     a VARmodel object which contains the estimated parameters and the estimated covariance matrices.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = Destabilisation","category":"page"},{"location":"#Destabilisation","page":"Index","title":"Destabilisation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Documentation for Destabilisation.","category":"page"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"coupling/","page":"Coupling to dynamical system","title":"Coupling to dynamical system","text":"CurrentModule = Destabilisation","category":"page"},{"location":"coupling/#Coupling-the-destabilataions-package-to-the-dynamical-system","page":"Coupling to dynamical system","title":"Coupling the destabilataions package to the dynamical system","text":"","category":"section"},{"location":"coupling/","page":"Coupling to dynamical system","title":"Coupling to dynamical system","text":"The struct DynamicalSystem allows acces to the parameter dependent dynamics of the underlying system and also gives information about how to comupte the observables of interest.","category":"page"},{"location":"coupling/","page":"Coupling to dynamical system","title":"Coupling to dynamical system","text":"DynamicalSystem\nDynamicalSystem(progressor,observable,x_init,p_init;p_bounds=nothing)","category":"page"},{"location":"coupling/#Destabilisation.DynamicalSystem","page":"Coupling to dynamical system","title":"Destabilisation.DynamicalSystem","text":"DynamicalSystem\n\nAn instance of the struct DynamicalSystem contains all the relevant information of the stochastic dynamical      system which we want to destabilize.\n\nFields\n\nprogressor::Function: The Argument progressor should contains a function that takes two arguments, each of type   Vector{Flaot64}, representing the current state variables v and the current parameter values p and returns   the state variables as a Vector{Flaot64} for the next timestep. I.e. this function describes the progression   of the dynamical system for one time step\nobservable::Function: This function should take the current state variables v and the current parameter values p,   both as Vector{Float64}, as input and return an output of type Vector{Float64} containing all the observables   of the system which are relevant for further analysis.\nv_init::Vector{Float64}: Initial values for the state space variables.\np_init::Vector{Float64}: Initial parameter values.\np_bounds::Union{Vector{Tuple},Nothing}: In case the parameter values are bounded to certain intervalls, the   bounds of each of these intervalls can be specified in this argument. I.e. the i-th tuple in p_bounds    represent the interval bounds for the i-th parameter. If p_bounds = nothing then it is assumes that there   are no restictions to the parameter values\nv_length::Int64: Number of state space variables\np_length::Int64: Number of parameters\nx_length::Int64: Number of observables\n\n\n\n\n\n","category":"type"},{"location":"coupling/#Destabilisation.DynamicalSystem-NTuple{4, Any}","page":"Coupling to dynamical system","title":"Destabilisation.DynamicalSystem","text":"DynamicalSystem(progressor,observable,v_init,p_init;p_bounds=nothing)\n\nAlternative initialisation of an element of type DynamicalSystem where v_length, p_length and      x_length are automatically computed.\n\n\n\n\n\n","category":"method"}]
}
